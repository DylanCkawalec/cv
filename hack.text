Yor Bridge
Yor
Invo Account Abstraction
_
reference link to technical architecture : Yor
_
Invo Bridge Architecture | Lucidchart
1. The Owned Account Proofs are NFTs that are non-transferable and attest to the signer, who is the client performing a commitment of their Aleo Record on other blockchains in the form of a Smart Contract. This contract validates
that the signature verifier of any Yor Bridge execution to send or spend token messages between two different chains has a valid proof that their account is owned on both the sending and receiving chain. The owner of both
accounts must prove that they have the Bridge Key, which is the only way the Yor Bridge Operator can execute the Match
Account
_
_
Proof transition function. If, and only if, the accounts of Alice and Bob are owned by the same
client, where Alice is Bob and Bob is Alice, then the bridge transitions to lock and redeem tokens on opposing chains will execute in a trustless manner. The only way to make the protocol 100% trustless is by using MP-HTLC (1).
We use this technique to ensure that the owner of these two separate accounts must prove they are the sole owner in a timely manner, which limits the potential risk for any account owner who may have had their Aleo Keys or
blockchain accounts compromised.
Concurrency and Computation - 2023 - Barbàra - MP‐HTLC Enabling blockchain interoperability through a multiparty.pdf
In order to ensure the Bridge Operator (in this case, Invo) can be trustless, MP-HTLC does suggest the protocol developer enable TLS signature patterns to encrypt messages to a large list of Bridge Operators who can trustlessly
sign operations to execute on the user's behalf in a private manner. For now, we believe this design is one of the first to ever implement a completely trustless atomic bridge using a Zero Knowledge Layer 1 Blockchain as the
trustless authority to relay messages between two different blockchain systems with tokens, records, or other ledger systems that deal with messages, finance, or governance protocols. This system enables a user to be a
trusted operator of their own bridge, instead of relying on bridge contracts to execute, which can be costly for the user. This also helps the industry move forward to start dealing with library functions that bridge tokens, instead
of 3rd party bridge operators conducting token bridging using delegated liquidity pools. In the AIMBC protocol standard, the contract standard set by the developers of Yor Bridge (Invo Technologies), the collateral issued
between two accounts owned by the same client ensures the liquidity provider on both chains that they are dealing in a fair and transparent manner that also ensures their right to privacy and interoperable finance. This system
depends on the user to pay the fees to both Aleo and the bridging chains to the operator who's executing the attestations, as well as performing guard operations to protect the pool's liquidity. We will advise that if developers do
use the Yor Library, they enable a new key pair called the Bridge Key, which should be secured under the same methods and conditions as the user's private key. The way to recover or import a bridge key can be done using any
traditional method to socially recover Owned Account proofs, which Invo Technologies believes can open the opportunity for trustless Social Recovery Protocols, Universal Blockchain Alliance Governance Protocols, and
cheaper bridging operations for any chains that use the AIMBC contract standard and the audited Yor Library. Users must trust that the contract liquidity is not faulty and that the AIMBC code has not been tampered with from the
Yor Bridge fork if developers deploy their own contracts with their own liquidity. This liquidity is meant to serve the general public, where all fees from bridged transactions help support trustless and fair token bridging to build a
more interoperable future for the blockchain alliance, foundations, and trusted custodians of Invo Technologies Inc.
Preliminary OAP Setup
1. Initialization of Scrambled Vector Order
A Scrambled
vec
_
_
order list of integers from 1 to 64 is created. This list represents the positions of bytes in the K1 key (a keccak256 hash) and is used to reorder the K1 key bytes based on
Aleo's requirements.
2. Key Generation on Both Chains
Unique sets of keys are generated for accounts on Ethereum and Aleo:
Ethereum accounts receive a private and public key pair.
Aleo accounts are assigned a private, public, and view key.
3. Creation of X1 Key
The Aleo private key and view key are used to generate a SHA256 hash, termed the X1 key.
4. Creation of Y1 Key
The X1 key and the Ethereum private key (X2) are used to generate another SHA256 hash, the Y1 key.
5. Creation of Y2 Key
The roles of X1 and X2 are reversed (X2 as input, X1 as secret) to generate the Y2 key, also using SHA256.
6. Generation of K1 Key
The Y1 and Y2 hashes (each 64 bytes) are concatenated and hashed using Keccak256 to produce the K1 key.
7. Reordering of K1 to EK1
The Scrambled
vec
_
_
order list is used to reorder the bytes of the K1 key to produce the EK1 key, which is the same key but in a different byte order.
8. Aleo Record Creation
The EK1 key is converted into ASCII representation and stored in 64 distinct slots in an Aleo record, which is associated with the Aleo public key.
9. Ethereum NFT Creation
An NFT representing the 'Owned Account Proof' is created on Ethereum, containing the EK1 key, Ethereum public key, and the transaction ID from the Aleo record.
The Bridge Key
The bridge key, known as Bridge
_
ETH, is created to link the 'Owned Account Proofs' on both the Aleo and Ethereum chains.
10. Creation of the Bridge Key
The Y1 and Y2 keys are used in reverse order (Y2+Y1) to generate the K2 key using Keccak256, in a process humorously referred to as the Y
_
Combinator function.
11. Formation of the new
_
order
The output of the Scrambled
_
vec
vec
_
_
order is concatenated into a single string, the new
_
order
_
vec, which is then referred to as the 192
_
byte
_
str.
12. Generation of the Bridge
_
Eth Hash
The 192
_
byte
_
str is used as input, and K2 as the secret, to generate the Bridge
_
Eth hash using AES
_
GCM. This allows for the original scrambled order of K1 to be reverted for later use.
13. Encryption of the Bridge Key
The Bridge key is encrypted in the wallet with a password for additional security.
This comprehensive process ensures that each account on both Ethereum and Aleo is securely linked and can be verified through cryptographic proofs, facilitating seamless interaction and
interoperability between the two chains. The use of hashing functions (SHA256 and Keccak256) and encryption (AES
_
GCM) provides robust security measures, while the unique key generation and
reordering mechanism ensure that each account is distinct and securely managed.
Bridge Operation Using Aleo: Detailed Procedural Documentation
A) Complete the Preliminary Setup!
This section outlines the initial steps required for setting up a bridge operation that facilitates an atomic swap using Aleo as a trustless intermediary between Ethereum and Binance Smart Chain
(BNB), involving Owned Account Proofs (OAPs) and detailed cryptographic processes.
0.0 Aleo Credit Transfer and Secret Generation Request:
Alice initiates the process by sending Aleo credit to the Bridge Operator's address using the Secret
_gen
_
request function. This action requests the Bridge Operator to prompt Alice to submit to
the Secret
_gen
_
Request function in the Yor Library, setting the stage for secure cryptographic operations.
1.0 Secret Request and Bridge Operator Acceptance:
Alice employs the Secret
_gen
_
request function to request a new 128-byte secret number ( R) from the Bridge Operator. The request is contingent on Alice opening a communication port with
the Bridge Operator within the first five minutes, ensuring timely and secure exchange.
1.1 Preliminary Key Generation by Bob:
Bob executes the Pre
lim
_
_
key_generation function to generate all necessary X, Y, and K keys for both the Alice and Bob accounts across ETH<>ALEO<>BNB. Bob then requests R from Alice,
awaiting her response to proceed with the cryptographic operations.
1.2 Exchange of R:
Once Alice receives R from the Bridge Operator, she forwards R to Bob. This step ensures both Alice and Bob are synchronized with the same foundational secret for subsequent encryption and
decryption processes.
1.3 Retrieval of EK1 and BK1 Proofs:
Alice requests a copy of her EK1 proof from the Ethereum chain, linked to the TxId of her OAP on Aleo. She retrieves the full EK1 proof from the Aleo record.
Similarly, Bob retrieves his BK1 proof from the BNB chain, linked to his OAP on Aleo, accessing the complete BK1 proof from the Aleo record.
1.4 Bridge Key Construction and OBS Generation:
Alice runs the build
k2
_
_proof function, conditional on Bob successfully generating the correct X and Y keys. She decrypts her Bridge
_
key_
ETH stored in her wallet using K2 to reveal her
ont
_
byte
_
str (OBS) key.
Bob mirrors this process for his Bridge
_
key_
BNB, decrypting it to reveal his OBS key.
1.5 OBS Exchange and Variable Storage:
Alice requests Bob's OBS and stores it under the bob
_
OBS variable, while her OBS is stored under the alice
_
OBS variable.
1.6 OBS Encryption and Submission:
Utilizing the submit
obs
_
_
set function, Alice encrypts both alice
OBS and bob
OBS with AES
_
_
_
GMC encryption using the secret R. She then sequentially submits the encrypted hashes to the
Bridge Operator, first for Alice's OBS and then for Bob's.
By following these steps, Alice and Bob, with the Bridge Operator acting as the intermediary, engage in a secure and trustless process to set the groundwork for an atomic swap. This preparation
involves secure cryptographic exchanges, including the generation, exchange, and submission of crucial keys and proofs, establishing a robust foundation for the subsequent phases of the bridge
operation.
Preliminary Bridge Operator Owned Account Proof Operations
2.0 : Bridge Operator Requests Alice for Alice's EK1 and BOB's BK1, where Alice sends Both through the same channel to the Bridge Operator. Before Alice sends the EK1 and BK1, she runs the
ascii
_
interpret function to run the EK1 and BK1 slot's through an interpreter that outputs the real EK1 and BK1 key in it's original form, and not in it's "0's and 1's" format which is the binary code
of the original EK1 and BK1 key's.
2.1 : The Bridge Operator ( BO) decrypts the alice
OBS and bob
_
_
OBS hash’s it received from Alice using the known R to reveal Alice and Bob’s ont
_
byte
_
str.
2.1.1: The Bridge Operator now has both Alice and Bob’s revealed eth
ont
_
_
byte
str and bnb
ont
_
_
_
byte
_
str and their EK1 and BK1 respectively.
2.2 : The Bridge Operator now uses the original
vec
_
_
order function where EK1(eth
ont
_
_
byte
_
str). this function takes the EK1 key, and depending on the order specified in the eth
ont
_
_
byte
_
str,
the hash uses the index order to place each character of the EK1 key starting from the [0…63] indexes, and builds a new variable vec
_
order using the order stated in the eth
ont
_
_
byte
_
str, where
every three characters, the index of the EK1 character is given a position in a new Vector list that starts off as 64 separate 0’s, and depending on the index and character revealed, the EK1 key is now
reordered to reveal the original K1 key order.
{Context information} EK1 is just a scrambled version of the K1 key, and the ont
_
byte
str tells the EK1 how to reorder itself for each character of the
_
`Ek1 `to form a new key called K1, which
was originally scrambled using the Scrambled
vec
_
_
order function during the preliminary OAP setup (stage 1) phase.
2.2.1 : This step is equivalent to step 2.2, but for the BK1 and bnb
ont
_
_
byte
_
str instead.
2.3 : The Bridge Operator now creates the bob
k1
_
_
hash using SHA256, where the revealed K1 (Bob’s k1 key), plus the concatenation of R + bnb
ont
_
_
byte
str which creates some hash called
_
bob
k1
hash.
_
_
{Context Information} SHA {( K1 + ( R + bnb
ont
_
_
byte
_
str) ) => verify_
bob
k1
_
_
hash}
2.3.1 : The Bridge Operator requests Alice, where Alice requests for Bob to build the SHA256 Hash of {( K1 + ( R + bnb
ont
_
_
byte
_
str) ) => verify_
bob
k1
_
_
hash}. Alice Returns to the Bridge
Operator in this request after an awaiting period the verify_
bob
k1
_
_
hash.
2.3.2 : The Bridge Operator checks by comparison if Alice’s sent verify_
bob
k1
hash = bob
k1
_
_
_
_
hash that bridge operator created in the initial step (2.3). If the result equals true, then continue
to the next step.
2.3.3: The bridge Operator spends the credit recieved from Alice in Step 0 where alice accredited the Bridge Operator Aleo Credit to run the match
Account
_
_
transition program which expects
to input the True value as the first input to the program. If the program detects that the input is true, the second input is the Bridge Operators address which makes the Bridge operator the owner
of the record to later switch the same contract to true for the third input parameter, which sets the first input value to false again which will mean the bridge operation has either closed or is
concluded. The 4th and 5th parameter is Alice’s Aleo public key address E
_
OAP, and Bob's Aleo public key address B
_
OAP. The 6th parameter is the time
_
commitment which tells the Bridge
Operator how many blocks does the operator have to bridge anything between the two addresses stated for whom is is Alice and and whom is Bob.
{Context Information} Since the E
OAP/ B
_
_
OAP program imported the match
account
_
_
transaction program, then this means Both Alice and Bob have the right to give the htlc
_
execution
program (which imports the owned
account
_
_proof program, which has imported the match
account
_
_
transaction program) the ability to include their OAP addresses in a bridge operator
executable pre-commitment input record which will use use the verified time
commitment stated in the match
account
_
_
_
transaction record that’s now been appended on chain. if the current
block exceeds the time
_
commitment stated in the record, the program will not execute. If the owned account proof’s match
account
_
_
transaction is currently false, then this htlc
_
execution
will also deny the ability for any peer to execute a pre-commitment record. The safety guarantee enabled in this three way record thread is that the block time and account proofs are valid and
relevant. All output information in these three programs ( match
account
_
_
transaction, owned
account
_
_proof, htlc
_
execution) should be verifiably correct and made public in order for bridge
operations to be accountable. This protects the Bridge Operator’s own ability to make pre-commitments with integrity during an finite period of time, which protects against attackers
attempting to falsify account transitions, expected collateral lending, and account commitments on the two chains exchanging messages. If any error occurs during this step, return Alice
the error “Accounts do not match“
, and then await to spend during the finite block period to close this match
account
_
_
transaction, which resets the process for both Alice and Bob who must re-
execute credit transfer. If Alice is Bob (where Bob is also Alice), then the transaction will match and continue to the next step.
Preliminary Bridge Operator Pre-Commitment for AIMBC Preparation and Execution
3.0 : If accounts match, then Alice is returned a message from the Bridge Operator “Please Provide your pre-commitment”
. Alice agree’s to build a commitment, s2, which is a Keccack256 hash that
concatenates [ R , K1, EY1 , BY2] where R is the random seed, K1 is Alice’s own account proof signature, EY1 is Alice’s own Y1 key, and BY2 which is Bob’s own Y2 key.
3.0.1 : Bob also agree’s to build a commitment, s1, which is a Keccack256 hash that concatenates [ R , K1, BY1 , EY2] where R is the random seed, K1 is Bob’s own account proof
signature, BY1 is Bob’s own Y1 key, and EY2 which is Alice’s own Y2 key.
Example diagram of step 3.0 pre-commitment => commit phase for both Alice and Bob, and Bridge
Operator
3.1 : When Alice can see that Bob has created his commitment s1, then Alice opens a new port for Bob to pass his commitment to the Alice, as the Bridge Operator is requesting that Alice submits
her Commitment first s2, and then Alice then sends Bob's commitment second s1 after requesting it from Bob's personal key file which should be from the same file Alice is using.
{Context Information} If the File’s Identity cannot be match, then this request will either fail now, or run a false value which will inevitably result in a failed pre-commitment/commitment pattern match
during the redemption phase which happens later in the process.
3.2 : The Bridge Operator Now owns s2 and s1 . The Bridge Operator runs the Scramble
order
_
_
vec function to generate a new random 192
_
byte
_
str which will be used by the bridge operator to
prove that commitments are true. The Bridge Operator creates some Hash H, using SHA3 where H = [ S2, S1 ] where S2 is some input, and S1 is some secret provided to generate some H. The
index order of H is then scrambled using the new
order
vec function which takes in some H and the 192
_
_
_
byte
str to return some Pre-Commitment hash.
_
{Context information} This is the same hash as H, except that the real order of the hash is mixed and can only be revealed by the Bridge Operator who’s the only one that can verify the input
statement in the record of the handshake-agreement program, where the value of handshake
_
hash (slots 1-64) equals the ASCII binary of the Pre-Commitment, where if the Bridge Operator, the
owner of collateral on both bridging chains can verify that the commitments made by Alice and Bob in the proceeding steps can post their own commitments to Ethereum and BNB chain, where if
the Commitments made and the true order of the pre-commitment is stated on the htlc-constract (AIMBC) matches the hash of the bridge operator’s pre-commitment, then Alice must be Bob.
3.3 : The bridge Operator posts this Pre-Commitment hash to the Aleo handshake-agreement program which expects all 64 slots to be filled, and the two E
OAP / B
_
_
OAP address's, along with the
updated time commitment that the bridge operator has to commit their own pre-commitment to Sender Chain using the ETH Token as gas received from Alice which you will see in the following
steps how much this is.
Reference
Yor
_
Invo Bridge Architecture | Lucidchart
HTLC-AIMBC Commitment Phase
4.0 : Alice commits ETH and agree’s to signatures of the future signature “claims” and posts S1.
4.1 : Bob Commits Proof S2
4.2 : BO commits real pre-commitment from the htlc handshake in the original order of H
4.2.1 : the BO finds that Alice and Bob commitments match the real commitment, and BO sends Bob the Eth
_
CC
4.3 : When ETH
AIMBC finds that Bob received the EThCC on BNB, then it redeems the ETH locked on the ETH
_
_
AIMBC
4.4 When ETH
AIMBC contract redeems, the BNB
_
_
AIMBC Contract swaps bob’s ETH
_
CC (USD) amount for the Token requested.